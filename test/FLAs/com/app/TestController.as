// com.app.TestController// Adam Riggs//package com.app {	import flash.display.Sprite;	import flash.events.*;	import flash.net.URLVariables;	import flash.text.TextField;	import flash.utils.Timer;		import gs.TweenMax;		import com.adam.utils.AppData;	import com.adam.events.MuleEvent;		public class TestController extends Sprite {				private var appData:AppData=AppData.instance;				//display objects		private var test:Test;				//control vars		private var controlTimer:Timer;		private var testRunning:Boolean;		private var blackoutRunning:Boolean;				private var shapingInterval:uint;		private var baselineInterval:uint;		private var contrastInterval:uint;				//private var shapingComponents:uint;		//private var baselineComponents:uint;		//private var contrastComponents:uint;				private var phaseState:String;		private var phaseArray:Array;		private var phaseCount:uint;		private var currentPhaseCount:uint;		private var nextphase:String;				private var componentState:String;		private var componentArray:Array;		private var componentCount:uint;				//vars for incrementing through the test		private var shapingCount:uint;		private var shapingMin:uint;		private var baselineCount:uint;		private var baselineMin:uint;				//control display		private var controlText:TextField;		//private var controlFormat:TextFormat;				//blackout		private var blackoutSprite:Sprite;		private var blackoutTimer:Timer;		private var blackoutInterval:uint;				//sql vars		private var participantID:String;		private var testID:String;		private var vars:URLVariables;				public function TestController(){						init();		}		//*****Initialization Routines				public function init(){			//this.visible = false;			trace("TestController() init");						initVars();			initEvents();						initTest();			initBlackout();			initControl();					}				private function initVars():void{					}				private function initEvents():void{			appData.eventManager.listen("testController", onTestController);		}				private function initTest():void{			trace("Main.initTest()");			test=new Test();			addChildAt(test,0);			//test.visible=false;			//test gets initialized after the participant submit button is clicked in that listener function onParticipant		}				private function initBlackout():void{						blackoutSprite=new Sprite();			drawBlackout();			blackoutSprite.visible=false;			addChildAt(blackoutSprite,1);						blackoutInterval=20000;			blackoutInterval/=10;			blackoutTimer=new Timer(blackoutInterval,1);			blackoutTimer.addEventListener("timer", onBlackoutTimer);						blackoutRunning=false;		}				private function initControl():void{			trace("Main.initControl()");						shapingCount=0;			shapingMin=1;			baselineCount=0;			baselineMin=3;						phaseArray=new Array("shaping", "baseline", "contrast");			componentArray=new Array(2,1,1);	//these start counting at 0, so 2 shaping phases means it has phases 0,1,2 for a total of 3			phaseCount=0;			currentPhaseCount=0;			componentCount=0;			phaseState=phaseArray[phaseCount];			componentState="FR1";						shapingInterval=1000*60*2;	//1000=1 second, so 1000*60*2 = 2 minutes			baselineInterval=1000*60*3;			contrastInterval=1000*60*3;						//instead of 2 mins it's 20 secs, 3 mins is 30 secs			shapingInterval/=6;			baselineInterval/=6;			contrastInterval/=6;						controlTimer=new Timer(shapingInterval);			controlTimer.addEventListener("timer", onControlTimer);			//incrementState();			//controlTimer.start();						nextphase="wait";		}		//*****Core Functionality				private function drawBlackout():void{			var blackoutColor:String="0x000000";			blackoutSprite.graphics.clear();			blackoutSprite.graphics.beginFill(uint(Number(blackoutColor)));			blackoutSprite.graphics.drawRect(0,0,appData.stageWidth,appData.stageHeight);		}				private function changeTestState(state:String, phase:uint):void{			//this is where the rules for the test phases are implemented						trace("\n state=="+state+", phase=="+phase);						//stop the control timer			controlTimer.stop();			controlTimer.reset();						//if we are repeating the same phase			if(phaseState==state){				//increment the counter for the number of times this phase has been run through				currentPhaseCount++;			} else {				//reassign the phaseState to the new phase and reset the counter to 0				phaseState=state;				currentPhaseCount=0;			}						switch(state){								case "shaping":					controlTimer.delay=shapingInterval;										shapingCount++;										switch(phase){						case 0:							componentState="FR1";							test.circleTimer.stop();							//test.hideReward();							test.testReward.alpha=0;							test.testCircle.flashing=true;							test.testBackground.showYellow();							test.circleReqTimer=false;							//test.circleReqClicks=1;							test.circleProbClick=0;													break;												case 1:							componentState="VR2";							test.circleTimer.stop();							//test.hideReward();							test.testReward.alpha=0;							test.testCircle.flashing=true;							test.testBackground.showYellow();							test.circleReqTimer=false;							//test.circleReqClicks=2;							test.circleProbClick=.5;																				break;												case 2:							componentState="VR4";							test.circleTimer.stop();							//test.hideReward();							test.testReward.alpha=0;							test.testCircle.flashing=true;							test.testBackground.showYellow();							test.circleReqTimer=false;							//test.circleReqClicks=4;							test.circleProbClick=.75;						break;					}				break;								case "baseline":										baselineCount++;									controlTimer.delay=baselineInterval;										switch(phase){						case 0:							componentState="Component 1";							test.circleTimer.stop();							//test.hideReward();							test.testReward.alpha=0;							test.testCircle.flashing=true;							test.testBackground.showRed();							test.circleReqTimer=true;							//test.circleReqClicks=1;							test.circleProbClick=0;						break;												case 1:							componentState="Component 2";							test.circleTimer.stop();							//test.hideReward();							test.testReward.alpha=0;							test.testCircle.flashing=true;							test.testBackground.showBlue();							test.circleReqTimer=true;							//test.circleReqClicks=1;							test.circleProbClick=0;						break;					}				break;								case "contrast":										controlTimer.delay=contrastInterval;									switch(phase){						case 0:							componentState="Component 1";							test.circleTimer.stop();							//test.hideReward();							test.testReward.alpha=0;							test.testCircle.flashing=true;							test.testBackground.showRed();							test.circleReqTimer=true;							//test.circleReqClicks=1;							test.circleProbClick=0;													break;												case 1:							componentState="Component 2";							test.circleTimer.stop();							//test.hideReward();							test.testReward.alpha=0;							test.testCircle.flashing=true;							test.testBackground.showBlue();							test.circleReqTimer=false;							//test.circleReqClicks=0;							test.circleProbClick=1;						break;					}				break;											}						updateCurrentTest();			controlTimer.start();			componentCount++;		}				private function blackout():void{			trace("\n blackout()");			//make the test blackout			//set a timer to bring it back			blackoutSprite.visible=true;			blackoutTimer.start();			controlTimer.stop();			//controlTimer.reset();	//??probably?			blackoutRunning=true;			pauseTest();		}				private function setPhaseCount(phase:String):void{			switch(phase){					case "wait":						phaseCount=0;					break;										case "baseline":						phaseCount=1;					break;										case "contrast":						phaseCount=2;					break;				}		}				private function incrementState():void{			//these are the rules for moving through the test						//trace("currentTest.nextphase=="+currentTest.nextphase);			trace("shapingCount=="+shapingCount);			trace("baselineCount=="+baselineCount);						//check if a phase has been completed			if(componentCount>componentArray[phaseCount]){				//if so then blackout				blackout();								if(nextphase!="wait"){					setPhaseCount(nextphase);					componentCount=0;					changeTestState(phaseArray[phaseCount],componentCount);									}			} else {				//if a phase has not been completed then advance to the next component				changeTestState(phaseArray[phaseCount],componentCount);			}			//changeTestState(phaseArray[phaseCount],componentCount);		}				private function updateCurrentTest():void{			//update the currentTest table in the database with the current state of the test						//this should be in the sqlProxy and be controlled through Database						vars=new URLVariables();						vars.table="currentTest";			vars.id="1";			vars.phase=phaseState;			vars.component=componentState;			vars.componentstart=new Date().time.toString();			//vars.nextphase="undefined";						appData.sqlProxy.updateSQL(vars);						//update the database object			appData.database.phase=phaseState;			appData.database.component=componentState;					}				private function resizeMe():void{			/*trace("test");			trace("appData.stageWidth=="+appData.stageWidth);			trace("appData.stageHeight=="+appData.stageHeight);*/			try{				test.testBackground.resizeMe();				drawBlackout();			} catch(e:Error){							}					}				public function startTest():void{			trace("testController.startTest()");			//test.init();			resizeMe();			setPhaseCount(nextphase);			//incrementState();			componentCount=0;			changeTestState(phaseArray[phaseCount],componentCount);			//controlTimer.start();			test.startCircle();			blackoutSprite.visible=false;			visible=true;		}				public function pauseTest():void{			//test.circleMove=false;			trace("testController.pauseTest()");			test.stopCircle();			controlTimer.stop();			testRunning=false;		}				public function unpauseTest():void{			trace("testController.unpauseTest()");			controlTimer.start();			test.startCircle();			testRunning=true;			blackoutSprite.visible=false;		}				public function resetTest():void{			trace("testController.resetTest()");			//this should also reset the currenttest table?			//I'm sure this doesn't work right yet...			test.stopCircle();			resizeMe();			controlTimer.reset();			initControl();			testRunning=false;		}				public function setNextPhase(np:String):void{			nextphase=np;			trace("testController.nextphase=="+nextphase);			trace("blackoutRunning=="+blackoutRunning+"\ttestRunning=="+testRunning);			if(!blackoutRunning && !testRunning && nextphase!="wait"){				trace("\n\n!blackoutrunning&&!testRunning");				//setPhaseCount(nextphase);				componentCount=0;				incrementState();				unpauseTest();				if(appData.database.currentTest.testStarted){					appData.eventManager.dispatch("database", {type:"setNextPhaseWait", sender:"testController"});				}			}		}				//*****Event Handlers		private function onControlTimer(e:TimerEvent):void{			incrementState();		}				private function onBlackoutTimer(e:TimerEvent):void{			trace("onBlackoutTimer()");						blackoutTimer.stop();			blackoutTimer.reset();			blackoutRunning=false;			trace("*****blackoutRunning=false");		}				private function onTestController(e:MuleEvent):void{			/*trace("e.data.sender=="+e.data.sender);			trace("e.data.type=="+e.data.type);*/			switch(e.data.type){								case "resize":					resizeMe();				break;								case "nextphase":					setNextPhase(e.data.nextphase);				break;							}		}		//*****Gets and Sets						//*****Utility Functions				public function show(){			this.visible = true;		}				public function hide(){			this.visible = false;		}				}}