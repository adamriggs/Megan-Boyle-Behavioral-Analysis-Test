// com.app.model.CurrentTestDataModel// Adam Riggs//package com.app.model{	import com.adam.events.MuleEvent;	import com.adam.utils.AppData;		import flash.display.Sprite;	import flash.events.*;	import flash.net.URLVariables;	import flash.utils.Timer;		public class CurrentTestDataModel {				private var appData:AppData=AppData.instance;				//vars		private var _xmlBaseline:XML;		private var _xmlContrast:XML;		private var _xmlShaping:XML;		private var _xmlStream:XML;		private var _dataObj:Object;		//*****counter vars				var circleClicked:int;		var rewardClicked:int;		var rewardDelivered:int;				//objects						//const		public const NAME:String="currentTestDataModel";		public const RETURNTYPE:String=NAME;		public const VIEW:String="currentTestDataView";				private static const _instance:CurrentTestDataModel = new CurrentTestDataModel(CurrentTestDataModelLock);				public function CurrentTestDataModel(lock:Class){			// Verify that the lock is the correct class reference.			if (lock != CurrentTestDataModelLock)			{				throw new Error("Invalid CurrentTestDataModel access.  Use CurrentTestDataModel.instance instead.");			} else {				init();			}		}		//*****Initialization Routines				public function init():void{			//this.visible = false;			debug("init()");						initVars();			initEvents();		}				private function initVars():void{			//local instances of other vars						//local vars			_xmlBaseline=new XML();			_xmlContrast=new XML();			_xmlShaping=new XML();			_xmlStream=new XML();			_dataObj=new Object();					}				private function initEvents():void{			appData.eventManager.listen(NAME, onCurrentTestDataModel);			appData.eventManager.listen("sql", onSQL);		}		//*****Core Functionality				private function processDataBaseline(rawData:String):void{			//debug("processDataBaseline()");			_xmlBaseline=new XML(rawData);			_dataObj.baseline=new Array();			//debug("xml - \n"+_xmlBaseline);						xmlToArray(_xmlBaseline,_dataObj.baseline);						//debug("_dataObj.baseline.length=="+_dataObj.baseline.length);						appData.eventManager.dispatch(VIEW, {type:"updatebaseline", sender:NAME, dataObj:appData.makeInterval(_dataObj.baseline)});					}				private function processDataContrast(rawData:String):void{			//debug("processDataContrast()");			_xmlContrast=new XML(rawData);			_dataObj.contrast=new Array();						xmlToArray(_xmlContrast,_dataObj.contrast);						appData.eventManager.dispatch(VIEW, {type:"updatecontrast", sender:NAME, dataObj:appData.makeInterval(_dataObj.contrast)});		}				private function processDataShaping(rawData:String):void{			//debug("processDataShaping()");			_xmlShaping=new XML(rawData);			_dataObj.shaping=new Array();						xmlToArray(_xmlShaping,_dataObj.shaping);						appData.eventManager.dispatch(VIEW, {type:"updateshaping", sender:NAME, dataObj:appData.makeInterval(_dataObj.shaping)});		}				private function processDataStream(rawData:String):void{			//debug("processDataStream()");			_xmlStream=new XML(rawData);			//debug("_xmlStream==\n"+_xmlStream);			_dataObj.stream=new Array();						xmlToArray(_xmlStream,_dataObj.stream);						appData.eventManager.dispatch(VIEW, {type:"updatestream", sender:NAME, dataObj:appData.makeInterval(_dataObj.stream)});		}				//private function makeInterval(arr:Array):Array{//			var iArr:Array=new Array();	//interval array//			var iStart:Number;//			var iEnd:Number;//			var iCount:uint=1;//			var prevComponent:String;//			var prevPhase:String;//			//			iStart=arr[0].timestamp;//			iEnd=iStart+appData.intervalSize;//			circleClicked=rewardClicked=rewardDelivered=0;//			prevComponent=arr[0].component;//			prevPhase=arr[0].phase;//			//			//debug("iEnd==            "+iEnd);//			//debug("arr[i].timestamp=="+arr[i].timestamp);//			//			for(var i:uint=0;i<arr.length;i++){//				//				while(arr[i].timestamp>iEnd || prevComponent!=arr[i].component || prevPhase!=arr[i].phase){//					//					//iArr.push({phase:arr[i].phase,phaseiteration:arr[i].phaseiteration,component:arr[i].component,clicks:circleClicked,deliveries:rewardDelivered,consumption:rewardClicked});//					//iArr.push({phase:prevPhase,phaseiteration:arr[i].phaseiteration,component:prevComponent,clicks:circleClicked,deliveries:rewardDelivered,consumption:rewardClicked});//					iArr.push({phase:arr[i].phase,phaseiteration:arr[i].phaseiteration,component:arr[i].component,clicks:circleClicked,deliveries:rewardDelivered,consumption:rewardClicked});//					//					iEnd=iEnd+appData.intervalSize;//					//					circleClicked=rewardClicked=rewardDelivered=0;//					prevComponent=arr[i].component;//					prevPhase=arr[i].phase;//				}//				//				incrementCounters(arr[i].event);//				//			}//			//			iArr.push({phase:arr[arr.length-1].phase,phaseiteration:arr[arr.length-1].phaseiteration,component:arr[arr.length-1].component,clicks:circleClicked,deliveries:rewardDelivered,consumption:rewardClicked});//			//			//debug("arr.length== "+arr.length);//			//debug("iArr.length=="+iArr.length);//			//			return iArr;//		}//		//		private function incrementCounters(str:String):void{//			switch(str){//				case "circle clicked"://					//debug("circle clicked");//					circleClicked++;//				break;//				//				case "reward clicked"://					//debug("reward clicked");//					rewardClicked++;//				break;//				//				case "reward delivered"://					//debug("reward delivered");//					rewardDelivered++;//				break;//				//				default://					debug("*unknown event - str=="+str);//				break;//			}//		}				private function xmlToArray(xml:XML, arr:Array):void{			//debug("xmlToArray()");						//debug("xml.RESULT.ROW.length()=="+xml.RESULT.ROW.length());						for(var i:uint=0;i<xml.RESULT.ROW.length();i++){				arr[i]=new Object();				arr[i].id=xml.RESULT.ROW[i].ID.toString();				arr[i].participant=xml.RESULT.ROW[i].PARTICIPANT.toString();				arr[i].test=xml.RESULT.ROW[i].TEST.toString();				arr[i].event=xml.RESULT.ROW[i].EVENT.toString();				arr[i].timestamp=xml.RESULT.ROW[i].TIMESTAMP.toString();				arr[i].phase=xml.RESULT.ROW[i].PHASE.toString();				arr[i].component=xml.RESULT.ROW[i].COMPONENT.toString();				arr[i].phaseiteration=xml.RESULT.ROW[i].PHASEITERATION.toString();			}						//debug("arr.length=="+arr.length);					}						//*****Event Handlers				private function onSQL(e:MuleEvent):void{			/*debug("onSQL()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){								case RETURNTYPE+"baseline":					try{						processDataBaseline(e.data.result);					}catch(err:Error){						//debug("error processing baseline sql result data");						//debug(e.data.result);					}				break;								case RETURNTYPE+"contrast":					try{						processDataContrast(e.data.result);					}catch(err:Error){						//debug("error processing contrast sql result data");						//debug(e.data.result);					}				break;								case RETURNTYPE+"shaping":					try{						processDataShaping(e.data.result);					}catch(err:Error){						//debug("error processing shaping sql result data");						//debug(e.data.result);					}				break;								case RETURNTYPE+"stream":					try{						processDataStream(e.data.result);					}catch(err:Error){						//debug("error processing stream sql result data");						//debug(e.data.result);					}				break;							}		}				private function onCurrentTestDataModel(e:MuleEvent):void{			/*debug("onCurrentTestDataModel()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){								default:					debug("onCurrentTestDataModel()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);				break;							}		}				//*****Gets and Sets				public static function get instance():CurrentTestDataModel{return _instance;}				public function get xmlBaseline():XML{return _xmlBaseline;}		public function get dataObj():Object{return _dataObj;}				//*****Utility Functions						//**debug		private function debug(str:String):void{			appData.debug(NAME,str);		}				}//end class}//end packageclass CurrentTestDataModelLock{}