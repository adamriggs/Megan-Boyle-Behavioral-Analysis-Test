// com.app.TestData// Adam Riggs//package com.app {	import flash.display.Sprite;	import flash.events.*;	import flash.net.URLVariables;		import gs.TweenLite;		import com.adam.utils.AppData;	import com.adam.events.MuleEvent;		public class TestData extends Sprite {				private var appData:AppData=AppData.instance;				public var intervalSize:Number;		public var intervalArray:Array;		private var intervalEnd:Date;				private var vars:URLVariables;				private var testXML:XML;				private var circleClicked, rewardClicked, rewardDelivered:uint;				public function TestData(){						init();		}		//*****Initialization Routines				public function init(){			//this.visible = false;			trace("TestData() init");						initVars();			initEvents();		}				private function initVars():void{			intervalSize=10;			intervalArray=new Array();					}				private function initEvents():void{			appData.eventManager.listen("sql", onSQL);		}		//*****Core Functionality				public function getTestData(testID:String):void{			selectSQL({keyword:"", table:"test", columns:"event,timestamp,phase,component,phaseiteration", where:"test='"+testID+"'"}, "testData");		}				private function selectSQL(data:Object,t:String="sqlResult"):void{			vars=new URLVariables();						vars.keyword=data.keyword;			vars.table=data.table;			vars.columns=data.columns;			if(data.where){vars.where=data.where;}			if(data.order){vars.order=data.order;}						appData.sqlProxy.selectSQL(vars, t);		}				private function createIntervalArray(testData:String):void{						intervalArray=new Array();						try{				//create xml				testXML=new XML(testData);								//find the first intervalEnd				intervalEnd=new Date(testXML.RESULT.ROW[0].TIMESTAMP);				trace("intervalEnd.time=="+intervalEnd.time);				intervalEnd=new Date(intervalEnd.time+(10*1000));				trace("intervalEnd.time=="+intervalEnd.time);								//initialize the counter variables				circleClicked=rewardClicked=rewardDelivered=0;								//step through the xml data and create interval data				for(var i:uint=0;i<testXML.RESULT.ROW.length();i++){										//test intervalEnd to make sure it isn't beyond the end boundary					trace("testXML.RESULT.ROW[testXML.RESULT.ROW.length()-1].TIMESTAMP=="+testXML.RESULT.ROW[testXML.RESULT.ROW.length()-1].TIMESTAMP);					if(intervalEnd.time>testXML.RESULT.ROW[testXML.RESULT.ROW.length()-1].TIMESTAMP){						intervalEnd=new Date(testXML.RESULT.ROW[testXML.RESULT.ROW.length()-1].TIMESTAMP);					}										//check if the current row is not beyond the interval boundary					if(testXML.RESULT.ROW[i].TIMESTAMP<intervalEnd.time){												//increment appropriate counter						incrementCounters(testXML.RESULT.ROW[i].EVENT);											} else {	//if the current row is beyond the interval boundary												//reset the intervalEnd to the new boundary						intervalEnd=new Date(testXML.RESULT.ROW[i].TIMESTAMP+(10*1000));												//write counter data to the array						intervalArray.push({phase:testXML.RESULT.ROW[i].PHASE,phaseiteration:testXML.RESULT.ROW[i].PHASEITERATION,component:testXML.RESULT.ROW[i].COMPONENT,clicks:circleClicked,deliveries:rewardDelivered,consumption:rewardClicked});												//reset counter data						circleClicked=rewardClicked=rewardDelivered=0;												//increment counter with currend row data						incrementCounters(testXML.RESULT.ROW[i].EVENT);					}									}								announceIntervalArray();							} catch(e:Error){				trace("TestData error in createIntervalArray()");				trace("testData=="+testData);								announceIntervalArray();			}					}				private function incrementCounters(type:String):void{			switch(type){											case "circle clicked":					circleClicked++;				break;								case "reward clicked":					rewardClicked++;				break;								case "reward delivered":					rewardDelivered++;				break;							}		}				private function announceIntervalArray():void{			appData.eventManager.dispatch("main", {type:"intervalData",array:intervalArray});		}		//*****Event Handlers				private function onSQL(e:MuleEvent):void{			switch(e.data.type){								case "testData":					createIntervalArray(e.data.result);				break;							}		}		//*****Gets and Sets						//*****Utility Functions				public function show(){			this.visible = true;		}				public function hide(){			this.visible = false;		}				}}